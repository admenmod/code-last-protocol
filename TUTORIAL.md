# Базовые конструкции
## Точки входа
Для каждой программируемой еденицы, есть свой отдельный главный файл. Код в главном файле выполняется один раз после создания управляемой сущности и называется прошивкой. В главном файле - прошивке, определются входные точки программы являющиеся обычными функциями, например __start__- выполнится каждый раз при запуске юнита.
```js
function __start__() {
	...
}
```
*(для упрощения будем вместо - управляемая сущность, говорить просто юнит, но на самом деле это может быть структура или еще что поинтереснее)*

Если вы задались вопросом, а в чем смысл описывать что то в функции `__start__`, ведь она выполняется 1 раз как и весь файл, то хочу отметить что эта функция выполнится еще и тогда когда юнит вышедший из строя снова запустится, при этом файл выполняется 1 раз при прошивке - перепрошивке юнита.

## События
*(Для мало знакомых с программированием и не терпеливых, совет, пропустить этот раздел и прочитать потом)*

Я понимаю что вам хочется поскорее узнать как управлять юнитом, но я настаиваю на том чтобы для начала немного рассказать про систему событий, если вы уже знаете что это такое, можете пропустить этот раздел, но советую прочитать его потом.

Вы можете работать с событиями используюя методы `on`, `once`, `off`, `emit`. Все они принимают первым, обязательным аргументом название - id события.

`on` - подписывает обработчик-слушатель на указанное событие и возвращает его. Это удобно когда вам надо сохранить обработчик-слушатель чтобы в будущем отписаться от события.
`once` - ведет себя также как `on` но отписывает обработчик после первого срабатывания.
`off` - отписывает указаный обработчик-слушатель от события
`emit` - вызывает событие (принимает доп.аргументы для обработчиков)
```js
function __start__() {
	emit('event', 'a', 'b', 'args[0]', 'args[1]', 'args[n]');
}

const event_listener = on('event', (a, b, ...args) => {
	...
});

off('event', event_listener);
```
Разширенная сигнатура функции `on` - `once` позволяет так же задать приоритет выполнения и `тег`, тег используется для того чтобы проще отписыватся от событий и может быть типа symbol или обычной строкой, например:
```js
const tag = Symbol('tag');

on('event', () => {
	...
}, -100, tag);
// приоритет сортируется по принципу массива, меньше нуля - раньше, больше нуля - позже

off('event', tag); // отпишет все обработчики с переданным тегом
```
Так же можно создать обьект с этими методами через `new EventEmitter();` и отдельное событие с помощью `new Event(this);`. Сигнатура методов такая же, у отдельного события опущен первый аргумент id события.

## Сценарии
Третьей и самой важной конструкцией являются сценарии. Они описываются следующим образом
```js
function* script() {
	...
}
```
**Обратите внимание что после ключевого слова `function` стоит звездочка!**

Можно определить несколько сценариев и встроить их друг в друга.
```js
function* main() {
	const data = yield* work('a', 'b', 'args[0]', 'args[1]', 'args[n]');
}

function* work(a, b, ...args) {
	...
}
```
Встраивание происходит с помощью ключевого слова `yield` со **звездочкой на конце**

Вот мы и добрались до управления юнитом, рассмотрим функции движения.
```js
function* main() {
	const status_code = yield* moveForward(3); // может принимать количество повторений
	// возвращает статус код ошибки или ничего если все хорошо

	if(not_error(status_code)) console.log(true);
	else console.log(status_code);

	// также можно найти другие сценарии в документации
	// turn(dir: number)
	// moveTo(pos: Vector2)
	// scan();
}
```
В этом примере сценарий `main`  передает управление сценарию `moveForward` и ждет пока он выполнится. Большинство  встроенных сценариев управления возвращают `void`, если все хорошо или статус код ошибки, если сценарий не может быть выполнен по какой то причине. Функция `not_error` проверяет не вернул ли сценарий ошибку.

## Система сценариев
Это все хорошо, но описать сценарий не достаточно чтобы его запустить. Для этого есть функция `script` которая возвращает интерфейс управления над выполнением скрипта.
```js
function __start__() {
	const main_script = script(main);

	main_script.run(this, 'OK');
}

function* main(msg) {
	console.log(msg);

	while(true) {
		yield* turn(-1); // поворот в лево
	}
}
```
Для запуска скрипта был вызван метод `run`. Он принимает в качестве аргумента контекст и параметры для сценария `run(this, ...args)`.

*(Если вы непонимаете что такое контекст и что еще за `this` то просто не думайте об этом, для того чтобы все работало правильно передавайте this первым аргументом  в `run` если незнаете что передать или просто опустите все аргументы, так тоже можно)*

Теперь вы знаете как создать рабочую прошивку, но разберем еще кое что. Сейчас наш скрипт выполняется бесконечно, но в реальности вы можете захотеть его остановить, для этого есть метод `reset`. Но это не все, в реальности также вам захочется запустить несколько скриптов одновременно, и сейчас не очень удобно управлять ими, создавая для каждого свою переменную, которую еще и хранить нужно в глобальной области видимости. Поскольку в основном вам не нужно будет запускать один и тот же сценарий одновременно несколько раз, есть более удобный способ управлять ими.
```js
function __start__() {
	const main_script = script(main);
	main_script.run();
// метод run возвращает свой контекст, тоесть обьект main_script
// что позволяет нам сразу запустить скрипт
	const main_script = script(main).run();
// чтобы не сохранять каждый раз переменную для скрипта
// можно воспользоватся методом script.mono
	const main_script = script.mono(main).run();
// он возвращает один и тот же интерфейс управления, для одного и того же сценария
// и теперь в таком случае нам не нужна переменная main_script
	script.mono(main).run();
}

function* main() {
	...
}
```

## Итог
Итого у нас есть три главные конструкции это entry points, events и script - входные точки, события и скрипты. Минимально рабочая прошивка выглядит как то так.
```js
function __start__() {
	script.mono(main).run();
}

function* main() {
	...
}
```
- entry_points
- events
- scripts

Рекомендуется упорядочивать все именно в таком виде, поскольку входные точки можно пересчитать по пальцам одной руки, событий как правило больше, но не намного, а скрипты рекомендуется дробить на более мелкие для удобства использования, так что их болеше всего.

## Немного сравнения с **Screeps** ›:)
При создании игры я вдохновлялся такими играми как Screeps, Space Engineers, Mindustry, по этому буду часто их упоминать и сравнивать.

Если вы играли в Screeps, то возможно уже заметили, что в отличие от Screeps, сдесь вам не нужно описывать логику в одном огромном цикле, еще и задом наперед (в смысле порядка ее выполнения).
Моя система программирования позволяет описывать сценарии действий обьединять их в *паролельное* выполнение. Например паролельно основному скрипту можно запустить, скрипт обнаружения врагов и вам не нужно будет трогать ваш основной скрипт, вы просто запускаете его рядом, а система сама под капотом с *мержит* эти два скрипта. А благодоря системе событий вы можете просто вызвать в скрипте событие `detect enemy` (например) и обработать его как вам угодно. Не затрагивая работу других частей программы которые не должны знать ничего лишнего, а могут описывать только то что они должны делать.

Настолько сложная система программирования юнитов, нужна для того чтобы вам было достаточно удобно описывать сложные вещи. В отличие от Screeps сдесь каждый юнит управляется отдельно, и прошивается только на базе, но при этом есть возможность отдавать ему комманды если он в зоне действия сети. Как видите концепция игры куда сложнее чем в screeps, еадеюсь получится сделать ее не менее интересной в итоге.